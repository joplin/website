"use strict";(self.webpackChunk_joplin_doc_builder=self.webpackChunk_joplin_doc_builder||[]).push([[573],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var s=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,a=function(e,t){if(null==e)return{};var n,s,a={},i=Object.keys(e);for(s=0;s<i.length;s++)n=i[s],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(s=0;s<i.length;s++)n=i[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=s.createContext({}),p=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return s.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},u=s.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,h=m["".concat(l,".").concat(u)]||m[u]||d[u]||i;return n?s.createElement(h,r(r({ref:t},c),{},{components:n})):s.createElement(h,r({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:a,r[1]=o;for(var p=2;p<i;p++)r[p]=n[p];return s.createElement.apply(null,r)}return s.createElement.apply(null,n)}u.displayName="MDXCreateElement"},547:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return r},default:function(){return d},frontMatter:function(){return i},metadata:function(){return o},toc:function(){return p}});var s=n(87462),a=(n(67294),n(3905));const i={sidebar_label:"Plugin system architecture",title:"Plugin system architecture",description:"The plugin system assumes a multi-process architecture, which is safer and easier to manage. For example if a plugin freezes or crashes, it doesn't bring down the app with it. It also makes it easi..."},r="Plugin system architecture",o={unversionedId:"dev/spec/plugins",id:"dev/spec/plugins",title:"Plugin system architecture",description:"The plugin system assumes a multi-process architecture, which is safer and easier to manage. For example if a plugin freezes or crashes, it doesn't bring down the app with it. It also makes it easi...",source:"@site/help/dev/spec/plugins.md",sourceDirName:"dev/spec",slug:"/dev/spec/plugins",permalink:"/fr/help/dev/spec/plugins",draft:!1,editUrl:"https://github.com/laurent22/joplin/tree/dev/readme/dev/spec/plugins.md",tags:[],version:"current",frontMatter:{sidebar_label:"Plugin system architecture",title:"Plugin system architecture",description:"The plugin system assumes a multi-process architecture, which is safer and easier to manage. For example if a plugin freezes or crashes, it doesn't bring down the app with it. It also makes it easi..."},sidebar:"helpSidebar",previous:{title:"Markdown with Front Matter Exporter/Importer",permalink:"/fr/help/dev/spec/interop_with_frontmatter"},next:{title:"Read-only",permalink:"/fr/help/dev/spec/read_only"}},l={},p=[{value:"Main architecture elements",id:"main-architecture-elements",level:2},{value:"Plugin script",id:"plugin-script",level:3},{value:"Sandbox proxy",id:"sandbox-proxy",level:3},{value:"Plugin host",id:"plugin-host",level:3},{value:"Plugin service",id:"plugin-service",level:3},{value:"Plugin runner",id:"plugin-runner",level:3},{value:"Plugin API",id:"plugin-api",level:3},{value:"Handling events between the plugin and the host",id:"handling-events-between-the-plugin-and-the-host",level:2},{value:"On Desktop",id:"on-desktop",level:3},{value:"On Mobile",id:"on-mobile",level:3},{value:"The <code>RemoteMessenger&lt;LocalInterface, RemoteInterface&gt;</code> class",id:"the-remotemessengerlocalinterface-remoteinterface-class",level:4},{value:"First: Queue the method call and wait for both messengers to be ready.",id:"first-queue-the-method-call-and-wait-for-both-messengers-to-be-ready",level:5},{value:"Second: Send all queued messages",id:"second-send-all-queued-messages",level:5},{value:"<code>RemoteMessenger</code> and callbacks",id:"remotemessenger-and-callbacks",level:4}],c={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,s.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"plugin-system-architecture"},"Plugin system architecture"),(0,a.kt)("div",{className:"donate-links"},(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.paypal.com/donate/?business=E8JMYD2LQ8MMA&no_recurring=0&item_name=I+rely+on+donations+to+maintain+and+improve+the+Joplin+open+source+project.+Thank+you+for+your+help+-+it+makes+a+difference%21&currency_code=EUR"},(0,a.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Donate-PayPal-green.svg",alt:"Donate using PayPal"}))," ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sponsors/laurent22/"},(0,a.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/GitHub-Badge.svg",alt:"Sponsor on GitHub"}))," ",(0,a.kt)("a",{parentName:"p",href:"https://www.patreon.com/joplin"},(0,a.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Patreon-Badge.svg",alt:"Become a patron"}))," ",(0,a.kt)("a",{parentName:"p",href:"https://joplinapp.org/donate/#donations"},(0,a.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Donate-IBAN.svg",alt:"Donate using IBAN"})))),(0,a.kt)("p",null,"The plugin system assumes a multi-process architecture, which is safer and easier to manage. For example if a plugin freezes or crashes, it doesn't bring down the app with it. It also makes it easier to find the source of problem when there is one - eg. we know that process X has crashed so the problem is with the plugin running inside. The alternative, to run everything within the same process, would make it very hard to make such a diagnostic. Once a plugin call is frozen in an infinite loop or crashes the app, we can't know anything."),(0,a.kt)("h2",{id:"main-architecture-elements"},"Main architecture elements"),(0,a.kt)("h3",{id:"plugin-script"},"Plugin script"),(0,a.kt)("p",null,"Written by the user and loaded by Joplin, it's a simple JavaScript file that makes calls to the plugin API. It is loaded in a separate process."),(0,a.kt)("h3",{id:"sandbox-proxy"},"Sandbox proxy"),(0,a.kt)("p",null,"It is loaded in the same process as the plugin script. Whenever the plugin script calls a plugin API function (eg. joplin.commands.execute) it goes through this proxy. The proxy then converts the call to a plain string and use IPC to send the call to the plugin host. The plugin host executes the function on the plugin API then sends back the result by IPC call again."),(0,a.kt)("h3",{id:"plugin-host"},"Plugin host"),(0,a.kt)("p",null,"The plugin host is simply the main application. Its role is to start and initialise the plugin service and to load plugins from the provided script files."),(0,a.kt)("h3",{id:"plugin-service"},"Plugin service"),(0,a.kt)("p",null,"It is used to load and run plugins. Running plugins is platform-specific, thus this part is injected into the service via a platform-specific Plugin Runner."),(0,a.kt)("h3",{id:"plugin-runner"},"Plugin runner"),(0,a.kt)("p",null,'This is the platform-specific way to load and run a plugin. For example, on desktop, it creates a new BrowserWindow (which is a new process), then load the script inside. On Cli, for now the "vm" package is used, so the plugin actually runs within the same process.'),(0,a.kt)("p",null,"The plugin runner also initialises the sandbox proxy and injects it into the plugin code."),(0,a.kt)("h3",{id:"plugin-api"},"Plugin API"),(0,a.kt)("p",null,"The plugin API is a light wrapper over Joplin's internal functions and services. All the platforms share some of the plugin API but there can also be some differences. For example, the desktop app exposes the text editor component commands, and so this part of the plugin API is available only on desktop. The difference between platforms is implemented using the PlatformImplementation class, which is injected in the plugin service on startup."),(0,a.kt)("h2",{id:"handling-events-between-the-plugin-and-the-host"},"Handling events between the plugin and the host"),(0,a.kt)("h3",{id:"on-desktop"},"On Desktop"),(0,a.kt)("p",null,"Handling events in plugins is relatively complicated due to the need to send IPC messages and the limitations of the IPC protocol, which in particular cannot transfer functions."),(0,a.kt)("p",null,"For example, let's say we define a command in the plugin:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"joplin.commands.register({\n    name: 'testCommand1',\n    label: 'My Test Command 1',\n}, {\n    onExecute: (args:any) => {\n        alert('Testing plugin command 1');\n    },\n});\n")),(0,a.kt)("p",null,'The "onExecute" event handler needs to be called whenever, for example, a toolbar button associated with this command is clicked. The problem is that it is not possible to send a function via IPC (which can only transfer plain objects), so there has to be a translation layer in between.'),(0,a.kt)("p",null,"The way it is done in Joplin is like so:"),(0,a.kt)("p",null,"In the ",(0,a.kt)("strong",{parentName:"p"},"sandbox proxy"),", the event handlers are converted to string event IDs and the original event handler is stored in a map before being sent to host via IPC. So in the example above, the command would be converted to this plain object:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n    name: 'testCommand1',\n    label: 'My Test Command 1',\n}, {\n    onExecute: '___event_handler_123',\n}\n")),(0,a.kt)("p",null,"Then, still in the sandbox proxy, we'll have a map called something like ",(0,a.kt)("inlineCode",{parentName:"p"},"eventHandlers"),", which now will have this content:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"eventHandlers['___event_handler_123'] = (args:any) => {\n    alert('Testing plugin command 1');\n}\n")),(0,a.kt)("p",null,"In the ",(0,a.kt)("strong",{parentName:"p"},"plugin runner")," (Host side), all the event IDs are converted to functions again, but instead of performing the action directly, it posts an IPC message back to the sandbox proxy using the provided event ID."),(0,a.kt)("p",null,"So in the host, the command will now look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n    name: 'testCommand1',\n    label: 'My Test Command 1',\n}, {\n    onExecute: (args:any) => {\n        postMessage('pluginMessage', { eventId: '___event_handler_123', args: args });\n    };\n}\n")),(0,a.kt)("p",null,"At this point, any code in the Joplin application can call the ",(0,a.kt)("inlineCode",{parentName:"p"},"onExecute")," function as normal without having to know about the IPC translation layer."),(0,a.kt)("p",null,"When the function onExecute is eventually called, the IPC message is sent back to the sandbox proxy, which will decode it and execute it."),(0,a.kt)("p",null,"So on the ",(0,a.kt)("strong",{parentName:"p"},"sandbox proxy"),", we'll have something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"window.addEventListener('message', ((event) => {\n    const eventId = getEventId(event); // Get back the event ID (implementation might be different)\n    const eventArgs = getEventArgs(event); // Get back the args (implementation might be different)\n    if (eventId) {\n        // And call the event handler\n        eventHandlers[eventId](...eventArgs);\n    }   \n}));\n")),(0,a.kt)("h3",{id:"on-mobile"},"On Mobile"),(0,a.kt)("p",null,"On mobile, not only is the main plugin script running in a separate process, but so are the note editor, renderer, and dialogs."),(0,a.kt)("p",null,"To simplify communication between these processes, a ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoteMessenger")," class is introduced."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"RemoteMessenger")," is ",(0,a.kt)("inlineCode",{parentName:"p"},"abstract")," and independent from how messages are sent. Each type of message channel should have a subclass of ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoteMessenger")," to handle communication over that channel type. For example, ",(0,a.kt)("inlineCode",{parentName:"p"},"WebViewToRNMessenger")," handles communication with React Native from within a React Native WebView. Similarly, ",(0,a.kt)("inlineCode",{parentName:"p"},"RNToWebViewMessenger")," handles communication with a React Native WebView from within React Native."),(0,a.kt)("h4",{id:"the-remotemessengerlocalinterface-remoteinterface-class"},"The ",(0,a.kt)("inlineCode",{parentName:"h4"},"RemoteMessenger<LocalInterface, RemoteInterface>")," class"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoteMessenger")," class simplifies communication over ",(0,a.kt)("inlineCode",{parentName:"p"},"postMessage"),". Its job is to convert asynchronous method calls to messages, then send these messages to another ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoteMessenger")," that handles them."),(0,a.kt)("mermaid",{value:"flowchart\n\tRemoteMessenger1<--postMessage--\x3eRemoteMessenger2"}),(0,a.kt)("p",null,"For example, if we have"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Dialogs\nexport interface MainProcessApi {\n    onSubmit: ()=> void;\n    onDismiss: ()=> void;\n    onError: (message: string)=> Promise<void>;\n}\n\nexport interface WebViewApi {\n    setCss: (css: string)=> void;\n    closeDialog: ()=> Promise<void>;\n    setButtons: (buttons: ButtonSpec[])=> void;\n}\n")),(0,a.kt)("p",null,"We might then create messengers like this:"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"In the WebView:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const webViewApiImpl: WebViewApi = {\n    // ... some implementation here ...\n    setCss: css => {} // ...\n};\n\n// Different messageChannelIds allow us to have multiple messengers communicate over the same channel.\n// Different IDs prevent the wrong messenger from acting on a message.\nconst messageChannelId = 'test-channel';\n\nconst messenger = new WebViewToRNMessenger<WebViewApi, MainProcessApi>(messageChannelId, webViewApiImpl);\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"In the main process:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const mainProcessApiImpl: WebViewApi = {\n    // ... some implementation here ...\n    closeDialog: () => {} // ...\n};\n\nconst messageChannelId = 'test-channel';\nconst messenger = new WebViewToRNMessenger<MainProcessApi, WebViewApi>(messageChannelId, mainProcessApiImpl);\n\n// We can now use the messenger.\n// Messages are all asynchronous.\nawait messenger.remoteApi.setCss('* { color: red; }');\n")),(0,a.kt)("p",null,"To call ",(0,a.kt)("inlineCode",{parentName:"p"},"messenger.remoteApi.setCss(...)"),", we use a process similar to the following:"),(0,a.kt)("h5",{id:"first-queue-the-method-call-and-wait-for-both-messengers-to-be-ready"},"First: Queue the method call and wait for both messengers to be ready."),(0,a.kt)("p",null,"To avoid sending messages that won't be received (and waiting indefinitely for a response), ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoteMessenger")," buffers messages until it receives a ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoteReady")," event."),(0,a.kt)("p",null,"When a messenger is ready, it sends a message with ",(0,a.kt)("inlineCode",{parentName:"p"},"kind: RemoteReady"),"."),(0,a.kt)("mermaid",{value:'flowchart\n\tpostMessage1(["postMessage({ kind: RemoteReady, ... })"])\n\trm1--1--\x3epostMessage1--2--\x3erm2\n\tsubgraph MainProcess\n\t\trm1["m1 = RemoteMessenger< MainProcessApi,WebViewApi >"]\n\tend\n\tsubgraph WebView\n\t\trm2["RemoteMessenger< WebViewApi,MainProcessApi >"]\n\tend'}),(0,a.kt)("p",null,"When a messenger receives a message with ",(0,a.kt)("inlineCode",{parentName:"p"},"kind: RemoteReady"),", it replies with the same message type."),(0,a.kt)("mermaid",{value:'flowchart\n\tpostMessage1(["postMessage({ kind: RemoteReady, ... })"])\n\trm2--3--\x3epostMessage1--4--\x3erm1\n\tsubgraph MainProcess\n\t\trm1["m1 = RemoteMessenger< MainProcessApi,WebViewApi >"]\n\tend\n\tsubgraph WebView\n\t\trm2["RemoteMessenger< WebViewApi,MainProcessApi >"]\n\tend'}),(0,a.kt)("h5",{id:"second-send-all-queued-messages"},"Second: Send all queued messages"),(0,a.kt)("p",null,"After both messengers are ready, we wend all queued messages. In this case, that's the ",(0,a.kt)("inlineCode",{parentName:"p"},"setCss")," message:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n    kind: MessageType.InvokeMethod,\n    methodPath: ['setCss'],\n    arguments: {\n        serializable: ['* { color: red; }'],\n\n        // If there were callbacks, we would assign them\n        // IDs and send the IDs here.\n        callbacks: [ null ],\n    },\n}\n")),(0,a.kt)("mermaid",{value:'flowchart\n\tpostMessage(["postMessage({ kind: InvokeMethod, ... })"])\n\trm1--2--\x3epostMessage--3--\x3erm2\n\tsubgraph MainProcess\n\t\tcallMethod(["await m1.remoteApi.setCss(\'...\')"])\n\t\tcallMethod--1--\x3erm1\n\t\trm1["m1 = RemoteMessenger< MainProcessApi,WebViewApi >"]\n\tend\n\tsubgraph WebView\n\t\trm2["RemoteMessenger< WebViewApi,MainProcessApi >"]\n\t\twebViewApiImpl["webViewApiImpl.setCss"]\n\t\trm2--4--\x3ewebViewApiImpl\n\tend'}),(0,a.kt)("p",null,"After handling the message, a result is returned also by ",(0,a.kt)("inlineCode",{parentName:"p"},"postMessage"),", this time with the ",(0,a.kt)("inlineCode",{parentName:"p"},"kind")," ",(0,a.kt)("inlineCode",{parentName:"p"},"ReturnValueResponse"),":"),(0,a.kt)("mermaid",{value:'flowchart\n\tpostMessage(["postMessage({ kind: ReturnValueResponse, ... })"])\n\trm2--6--\x3epostMessage--7--\x3erm1\n\tsubgraph WebView\n\t\trm2["RemoteMessenger< WebViewApi,MainProcessApi >"]\n\t\twebViewApiImpl["webViewApiImpl.setCss"]\n\t\twebViewApiImpl--5--\x3erm2\n\tend\n\tsubgraph MainProcess\n\t\trm1["m1 = RemoteMessenger< MainProcessApi,WebViewApi >"]\n\t\tcallMethod(["await m1.remoteApi.setCss(\'...\')"])\n\t\trm1--8--\x3ecallMethod\n\tend'}),(0,a.kt)("p",null,"After receiving the response, the ",(0,a.kt)("inlineCode",{parentName:"p"},"setCss")," call resolves."),(0,a.kt)("p",null,"On mobile, we address the same problem in similar, but more generalized way.  We define a ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoteMessenger")," class that handles ",(0,a.kt)("inlineCode",{parentName:"p"},"postMessage")," communication."),(0,a.kt)("h4",{id:"remotemessenger-and-callbacks"},(0,a.kt)("inlineCode",{parentName:"h4"},"RemoteMessenger")," and callbacks"),(0,a.kt)("p",null,"Suppose we call a method in a way similar to the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"messenger.remoteApi.joplin.plugins.register({\n    onStart: async () => {\n        console.log('testing');\n    },\n    test: 'test',\n});\n")),(0,a.kt)("p",null,"We can't send callbacks over ",(0,a.kt)("inlineCode",{parentName:"p"},"postMessage"),". As such, we assign the ",(0,a.kt)("inlineCode",{parentName:"p"},"onStart")," callback an ID and send the ID instead. The message might look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n    kind: MessageType.InvokeMethod,\n    methodPath: ['joplin', 'plugins', 'register'],\n    arguments: {\n        serializable: [\n            {\n                onStart: null,\n                test: 'test',\n            }\n        ],\n        callbacks: [\n            {\n                onStart: 'some-generated-id-for-onStart',\n                test: null,\n            }\n        ],\n    },\n    respondWithId: 'another-autogenerated-id',\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),": As before, the ",(0,a.kt)("inlineCode",{parentName:"p"},"respondWithId")," connects a method call to its return value (the return value has the same ID)."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"arguments.callbacks")," object contains ",(0,a.kt)("strong",{parentName:"p"},"only")," callback IDs and the ",(0,a.kt)("inlineCode",{parentName:"p"},"arguments.serializable")," object contains ",(0,a.kt)("strong",{parentName:"p"},"only")," the serialisable arguments. The two objects otherwise should have the same structure. These two objects are merged by the ",(0,a.kt)("inlineCode",{parentName:"p"},"RemoteMessenger")," that receives the message:"),(0,a.kt)("mermaid",{value:'flowchart\n\tcallbacks[arguments.callbacks]\n\tserializable[arguments.serializable]\n\n\tcallbacks--"only callbacks"--\x3eoriginal\n\tserializable--"only properties not in callbacks"--\x3eoriginal'}),(0,a.kt)("p",null,"Callbacks are called by sending an ",(0,a.kt)("inlineCode",{parentName:"p"},"InvokeMethod")," message similar to the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n    kind: MessageType.InvokeMethod,\n    methodPath: ['__callbacks', 'callback-id-here'],\n    arguments: { ... },\n    respondWithId: 'some-autogenerated-id-here',\n}\n")))}d.isMDXComponent=!0}}]);