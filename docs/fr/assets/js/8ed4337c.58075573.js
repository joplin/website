"use strict";(self.webpackChunk_joplin_doc_builder=self.webpackChunk_joplin_doc_builder||[]).push([[573],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||r;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},547:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return r},metadata:function(){return o},toc:function(){return p}});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_label:"Plugin system architecture",title:"Plugin system architecture",description:"The plugin system assumes a multi-process architecture, which is safer and easier to manage. For example if a plugin freezes or crashes, it doesn't bring down the app with it. It also makes it easi..."},s="Plugin system architecture",o={unversionedId:"dev/spec/plugins",id:"dev/spec/plugins",title:"Plugin system architecture",description:"The plugin system assumes a multi-process architecture, which is safer and easier to manage. For example if a plugin freezes or crashes, it doesn't bring down the app with it. It also makes it easi...",source:"@site/help/dev/spec/plugins.md",sourceDirName:"dev/spec",slug:"/dev/spec/plugins",permalink:"/fr/help/dev/spec/plugins",draft:!1,editUrl:"https://github.com/laurent22/joplin/tree/dev/readme/dev/spec/plugins.md",tags:[],version:"current",frontMatter:{sidebar_label:"Plugin system architecture",title:"Plugin system architecture",description:"The plugin system assumes a multi-process architecture, which is safer and easier to manage. For example if a plugin freezes or crashes, it doesn't bring down the app with it. It also makes it easi..."},sidebar:"helpSidebar",previous:{title:"Markdown with Front Matter Exporter/Importer",permalink:"/fr/help/dev/spec/interop_with_frontmatter"},next:{title:"Read-only",permalink:"/fr/help/dev/spec/read_only"}},l={},p=[{value:"Main architecture elements",id:"main-architecture-elements",level:2},{value:"Plugin script",id:"plugin-script",level:3},{value:"Sandbox proxy",id:"sandbox-proxy",level:3},{value:"Plugin host",id:"plugin-host",level:3},{value:"Plugin service",id:"plugin-service",level:3},{value:"Plugin runner",id:"plugin-runner",level:3},{value:"Plugin API",id:"plugin-api",level:3},{value:"Handling events between the plugin and the host",id:"handling-events-between-the-plugin-and-the-host",level:2}],c={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"plugin-system-architecture"},"Plugin system architecture"),(0,i.kt)("div",{className:"donate-links"},(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://www.paypal.com/donate/?business=E8JMYD2LQ8MMA&no_recurring=0&item_name=I+rely+on+donations+to+maintain+and+improve+the+Joplin+open+source+project.+Thank+you+for+your+help+-+it+makes+a+difference%21&currency_code=EUR"},(0,i.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Donate-PayPal-green.svg",alt:"Donate using PayPal"}))," ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/sponsors/laurent22/"},(0,i.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/GitHub-Badge.svg",alt:"Sponsor on GitHub"}))," ",(0,i.kt)("a",{parentName:"p",href:"https://www.patreon.com/joplin"},(0,i.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Patreon-Badge.svg",alt:"Become a patron"}))," ",(0,i.kt)("a",{parentName:"p",href:"https://joplinapp.org/donate/#donations"},(0,i.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Donate-IBAN.svg",alt:"Donate using IBAN"})))),(0,i.kt)("p",null,"The plugin system assumes a multi-process architecture, which is safer and easier to manage. For example if a plugin freezes or crashes, it doesn't bring down the app with it. It also makes it easier to find the source of problem when there is one - eg. we know that process X has crashed so the problem is with the plugin running inside. The alternative, to run everything within the same process, would make it very hard to make such a diagnostic. Once a plugin call is frozen in an infinite loop or crashes the app, we can't know anything."),(0,i.kt)("h2",{id:"main-architecture-elements"},"Main architecture elements"),(0,i.kt)("h3",{id:"plugin-script"},"Plugin script"),(0,i.kt)("p",null,"Written by the user and loaded by Joplin, it's a simple JavaScript file that makes calls to the plugin API. It is loaded in a separate process."),(0,i.kt)("h3",{id:"sandbox-proxy"},"Sandbox proxy"),(0,i.kt)("p",null,"It is loaded in the same process as the plugin script. Whenever the plugin script calls a plugin API function (eg. joplin.commands.execute) it goes through this proxy. The proxy then converts the call to a plain string and use IPC to send the call to the plugin host. The plugin host executes the function on the plugin API then sends back the result by IPC call again."),(0,i.kt)("h3",{id:"plugin-host"},"Plugin host"),(0,i.kt)("p",null,"The plugin host is simply the main application. Its role is to start and initialise the plugin service and to load plugins from the provided script files."),(0,i.kt)("h3",{id:"plugin-service"},"Plugin service"),(0,i.kt)("p",null,"It is used to load and run plugins. Running plugins is platform-specific, thus this part is injected into the service via a platform-specific Plugin Runner."),(0,i.kt)("h3",{id:"plugin-runner"},"Plugin runner"),(0,i.kt)("p",null,'This is the platform-specific way to load and run a plugin. For example, on desktop, it creates a new BrowserWindow (which is a new process), then load the script inside. On Cli, for now the "vm" package is used, so the plugin actually runs within the same process.'),(0,i.kt)("p",null,"The plugin runner also initialises the sandbox proxy and injects it into the plugin code."),(0,i.kt)("h3",{id:"plugin-api"},"Plugin API"),(0,i.kt)("p",null,"The plugin API is a light wrapper over Joplin's internal functions and services. All the platforms share some of the plugin API but there can also be some differences. For example, the desktop app exposes the text editor component commands, and so this part of the plugin API is available only on desktop. The difference between platforms is implemented using the PlatformImplementation class, which is injected in the plugin service on startup."),(0,i.kt)("h2",{id:"handling-events-between-the-plugin-and-the-host"},"Handling events between the plugin and the host"),(0,i.kt)("p",null,"Handling events in plugins is relatively complicated due to the need to send IPC messages and the limitations of the IPC protocol, which in particular cannot transfer functions."),(0,i.kt)("p",null,"For example, let's say we define a command in the plugin:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"joplin.commands.register({\n    name: 'testCommand1',\n    label: 'My Test Command 1',\n}, {\n    onExecute: (args:any) => {\n        alert('Testing plugin command 1');\n    },\n});\n")),(0,i.kt)("p",null,'The "onExecute" event handler needs to be called whenever, for example, a toolbar button associated with this command is clicked. The problem is that it is not possible to send a function via IPC (which can only transfer plain objects), so there has to be a translation layer in between.'),(0,i.kt)("p",null,"The way it is done in Joplin is like so:"),(0,i.kt)("p",null,"In the ",(0,i.kt)("strong",{parentName:"p"},"sandbox proxy"),", the event handlers are converted to string event IDs and the original event handler is stored in a map before being sent to host via IPC. So in the example above, the command would be converted to this plain object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n    name: 'testCommand1',\n    label: 'My Test Command 1',\n}, {\n    onExecute: '___event_handler_123',\n}\n")),(0,i.kt)("p",null,"Then, still in the sandbox proxy, we'll have a map called something like ",(0,i.kt)("inlineCode",{parentName:"p"},"eventHandlers"),", which now will have this content:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"eventHandlers['___event_handler_123'] = (args:any) => {\n    alert('Testing plugin command 1');\n}\n")),(0,i.kt)("p",null,"In the ",(0,i.kt)("strong",{parentName:"p"},"plugin runner")," (Host side), all the event IDs are converted to functions again, but instead of performing the action directly, it posts an IPC message back to the sandbox proxy using the provided event ID."),(0,i.kt)("p",null,"So in the host, the command will now look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"{\n    name: 'testCommand1',\n    label: 'My Test Command 1',\n}, {\n    onExecute: (args:any) => {\n        postMessage('pluginMessage', { eventId: '___event_handler_123', args: args });\n    };\n}\n")),(0,i.kt)("p",null,"At this point, any code in the Joplin application can call the ",(0,i.kt)("inlineCode",{parentName:"p"},"onExecute")," function as normal without having to know about the IPC translation layer."),(0,i.kt)("p",null,"When the function onExecute is eventually called, the IPC message is sent back to the sandbox proxy, which will decode it and execute it."),(0,i.kt)("p",null,"So on the ",(0,i.kt)("strong",{parentName:"p"},"sandbox proxy"),", we'll have something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"window.addEventListener('message', ((event) => {\n    const eventId = getEventId(event); // Get back the event ID (implementation might be different)\n    const eventArgs = getEventArgs(event); // Get back the args (implementation might be different)\n    if (eventId) {\n        // And call the event handler\n        eventHandlers[eventId](...eventArgs);\n    }   \n}));\n")))}h.isMDXComponent=!0}}]);