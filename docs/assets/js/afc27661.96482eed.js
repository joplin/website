"use strict";(self.webpackChunk_joplin_doc_builder=self.webpackChunk_joplin_doc_builder||[]).push([[4084],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return y}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,y=d["".concat(l,".").concat(u)]||d[u]||h[u]||i;return n?a.createElement(y,o(o({ref:t},c),{},{components:n})):a.createElement(y,o({ref:t},c))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5149:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return o},default:function(){return h},frontMatter:function(){return i},metadata:function(){return s},toc:function(){return p}});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_label:"Encryption",title:"Encryption",description:"Encrypted data is encoded to ASCII because encryption/decryption functions in React Native can only deal with strings. So for compatibility with all the apps we need to use the lowest common denomi..."},o="Encryption",s={unversionedId:"dev/spec/e2ee/index",id:"dev/spec/e2ee/index",title:"Encryption",description:"Encrypted data is encoded to ASCII because encryption/decryption functions in React Native can only deal with strings. So for compatibility with all the apps we need to use the lowest common denomi...",source:"@site/help/dev/spec/e2ee/index.md",sourceDirName:"dev/spec/e2ee",slug:"/dev/spec/e2ee/",permalink:"/help/dev/spec/e2ee/",draft:!1,editUrl:"https://github.com/laurent22/joplin/tree/dev/readme/dev/spec/e2ee/index.md",tags:[],version:"current",frontMatter:{sidebar_label:"Encryption",title:"Encryption",description:"Encrypted data is encoded to ASCII because encryption/decryption functions in React Native can only deal with strings. So for compatibility with all the apps we need to use the lowest common denomi..."},sidebar:"helpSidebar",previous:{title:"Desktop application styling",permalink:"/help/dev/spec/desktop_styling"},next:{title:"E2EE workflow",permalink:"/help/dev/spec/e2ee/workflow"}},l={},p=[{value:"Encrypted data format",id:"encrypted-data-format",level:2},{value:"Header",id:"header",level:3},{value:"Data chunk",id:"data-chunk",level:3},{value:"Master Keys",id:"master-keys",level:2},{value:"Encryption Service",id:"encryption-service",level:2},{value:"Encryption workflow",id:"encryption-workflow",level:2},{value:"Enabling and disabling encryption",id:"enabling-and-disabling-encryption",level:2},{value:"Types of keys",id:"types-of-keys",level:2},{value:"Master password",id:"master-password",level:2},{value:"Public-private key pairs",id:"public-private-key-pairs",level:2}],c={toc:p},d="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"encryption"},"Encryption"),(0,r.kt)("div",{className:"donate-links"},(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.paypal.com/donate/?business=E8JMYD2LQ8MMA&no_recurring=0&item_name=I+rely+on+donations+to+maintain+and+improve+the+Joplin+open+source+project.+Thank+you+for+your+help+-+it+makes+a+difference%21&currency_code=EUR"},(0,r.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Donate-PayPal-green.svg",alt:"Donate using PayPal"}))," ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/sponsors/laurent22/"},(0,r.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/GitHub-Badge.svg",alt:"Sponsor on GitHub"}))," ",(0,r.kt)("a",{parentName:"p",href:"https://www.patreon.com/joplin"},(0,r.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Patreon-Badge.svg",alt:"Become a patron"}))," ",(0,r.kt)("a",{parentName:"p",href:"https://joplinapp.org/donate/#donations"},(0,r.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Donate-IBAN.svg",alt:"Donate using IBAN"})))),(0,r.kt)("p",null,"Encrypted data is encoded to ASCII because encryption/decryption functions in React Native can only deal with strings. So for compatibility with all the apps we need to use the lowest common denominator."),(0,r.kt)("h2",{id:"encrypted-data-format"},"Encrypted data format"),(0,r.kt)("h3",{id:"header"},"Header"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Identifier"),(0,r.kt)("td",{parentName:"tr",align:null},'3 chars ("JED")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Version number"),(0,r.kt)("td",{parentName:"tr",align:null},"2 chars (Hexa string)")))),(0,r.kt)("p",null,"This is followed by the encryption metadata:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Length"),(0,r.kt)("td",{parentName:"tr",align:null},"6 chars (Hexa string)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Encryption method"),(0,r.kt)("td",{parentName:"tr",align:null},"2 chars (Hexa string)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Master key ID"),(0,r.kt)("td",{parentName:"tr",align:null},"32 chars (Hexa string)")))),(0,r.kt)("p",null,"See ",(0,r.kt)("inlineCode",{parentName:"p"},"lib/services/e2ee/EncryptionService.ts")," for the list of available encryption methods."),(0,r.kt)("h3",{id:"data-chunk"},"Data chunk"),(0,r.kt)("p",null,"The data is encoded in one or more chunks for performance reasons. That way it is possible to take a block of data from one file and encrypt it to another block in another file. Encrypting/decrypting the whole file in one go would not work (on mobile especially)."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"Size"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Length"),(0,r.kt)("td",{parentName:"tr",align:null},"6 chars (Hexa string)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Data"),(0,r.kt)("td",{parentName:"tr",align:null},'("Length" bytes) (ASCII)')))),(0,r.kt)("h2",{id:"master-keys"},"Master Keys"),(0,r.kt)("p",null,"The master keys are used to encrypt and decrypt data. They can be generated from the Encryption Service and are saved to the database. They are themselves encrypted via a user password using a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/laurent22/joplin/blob/b5b02d8d7bce2c07c89fef50103e1399d792b75e/packages/lib/services/e2ee/EncryptionService.ts#L373"},"strong encryption method"),"."),(0,r.kt)("p",null,"These encrypted master keys are transmitted with the sync data so that they can be available to each client. Each client will need to supply the user password to decrypt each key."),(0,r.kt)("p",null,"The application supports multiple master keys in order to handle cases where one offline client starts encrypting notes, then another offline client starts encrypting notes too, and later both sync. Both master keys will have to be decrypted separately with the user password."),(0,r.kt)("p",null,"Only one master key can be active for encryption purposes. For decryption, the algorithm will check the Master Key ID in the header, then check if it's available to the current app and, if so, use this for decryption."),(0,r.kt)("h2",{id:"encryption-service"},"Encryption Service"),(0,r.kt)("p",null,"The applications make use of the ",(0,r.kt)("inlineCode",{parentName:"p"},"EncryptionService"),' class to handle encryption and decryption. Before it can be used, a least one master key must be loaded into it and be marked as "active".'),(0,r.kt)("h2",{id:"encryption-workflow"},"Encryption workflow"),(0,r.kt)("p",null,"Items are encrypted only during synchronisation, when they are serialised (via ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseItem.serializeForSync"),"), so before being sent to the sync target."),(0,r.kt)("p",null,"They are decrypted by DecryptionWorker in the background."),(0,r.kt)("p",null,"The apps handle displaying both decrypted and encrypted items, so that user is aware that these items are there even if not yet decrypted. Encrypted items are mostly read-only to the user, except that they can be deleted."),(0,r.kt)("h2",{id:"enabling-and-disabling-encryption"},"Enabling and disabling encryption"),(0,r.kt)("p",null,"Enabling/disabling E2EE while two clients are in sync might have an unintuitive behaviour (although that behaviour might be correct), so below some scenarios are explained:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If client 1 enables E2EE, all items will be synced to target and will appear encrypted on target. Although all items have been re-uploaded to the target, their timestamps did ",(0,r.kt)("em",{parentName:"li"},"not")," change (because the item data itself has not changed, only its representation). Because of this, client 2 will not re-download the items - it does not need to do so anyway since it has already the item data."),(0,r.kt)("li",{parentName:"ul"},"When a client sync and download a master key for the first time, encryption will be automatically enabled (user will need to supply the master key password). In that case, all items that are not encrypted will be re-synced. Uploading only non-encrypted items is an optimisation since if an item is already encrypted locally it means it's encrypted on target too."),(0,r.kt)("li",{parentName:"ul"},"If both clients are in sync with E2EE enabled: if client 1 disable E2EE, it's going to re-upload all the items unencrypted. Client 2 again will not re-download the items for the same reason as above (data did not change, only representation). Note that user ",(0,r.kt)("em",{parentName:"li"},"must")," manually disable E2EE on all clients otherwise some will continue to upload encrypted items. Since synchronisation is stateless, clients do not know whether other clients use E2EE or not so this step has to be manual."),(0,r.kt)("li",{parentName:"ul"},"Although messy, Joplin supports having some clients send encrypted items and others unencrypted ones. The situation gets resolved once all the clients have the same E2EE settings."),(0,r.kt)("li",{parentName:"ul"},"Currently, there is no way to delete encryption keys if you do not need them anymore or if you disabled the encryption completely. You will get a persistent notification to provide a Master Key password on a new device, even if encryption is disabled. Entering the Master Key(s) password and still having the encryption disabled will get rid of the notification. See ",(0,r.kt)("a",{parentName:"li",href:"https://discourse.joplinapp.org/t/delete-e2ee-master-keys/906"},"Delete E2EE Master Keys")," for more info.")),(0,r.kt)("h2",{id:"types-of-keys"},"Types of keys"),(0,r.kt)("p",null,"There are two types of key:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Data keys"),", which are used to encrypt Joplin items, such as notes, notebooks, tags, etc. when E2EE is enabled. A data key is generated when the user enables E2EE. Data keys are also dynamically generated when a user shares a notebook with another user. In this case, we create a separate key, so that the recipient can only decrypt this specific notebook."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Public-private key pairs"),", which are used to transfer secrets between users.")),(0,r.kt)("h2",{id:"master-password"},"Master password"),(0,r.kt)("p",null,"The master password is used to encrypt E2EE data keys as well as the user's private key."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"It is possible to change the master password")," - in this case, all keys are reencrypted with the new password. The data, notes, notebooks, etc. does not need to be reencrypted."),(0,r.kt)("p",null,"If a master password is forgotten it's not possible to recover it. ",(0,r.kt)("strong",{parentName:"p"},"It is however possible to reset it"),". In that case, all associated keys are disabled, and the public-private key pair is regenerated. In practice it means that any content that was encrypted with the forgotten password can no longer be decrypted."),(0,r.kt)("h2",{id:"public-private-key-pairs"},"Public-private key pairs"),(0,r.kt)("p",null,"Public-private key pairs (PPK) are used to transfer secrets between users. Specifically, they are used when sharing a notebook while E2EE is enabled. The workflow is as follow:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Alice shares a notebook with Bob"),(0,r.kt)("li",{parentName:"ul"},"Since the notebook is encrypted, Alice also sends the key to Bob, but it needs to be encrypted too."),(0,r.kt)("li",{parentName:"ul"},"To do so, she downloads Bob's public key and encrypt the key with it"),(0,r.kt)("li",{parentName:"ul"},"When accepting the share, Bob receives this key"),(0,r.kt)("li",{parentName:"ul"},"Bob decrypts it with his private key"),(0,r.kt)("li",{parentName:"ul"},"Once decrypted, he reencrypts it with his master password")),(0,r.kt)("p",null,"At this point, both users have a copy of the key and can share notes over E2EE."),(0,r.kt)("p",null,"A user can only have one PPK."),(0,r.kt)("p",null,"PPKs are generated automatically when E2EE is enabled and when the user synchronises. They are then stored in info.json on the sync target. The key is generated during sync because otherwise multiple clients could generate a PPK, and then there would be a conflict to decide which PPK should be kept. By doing it during sync, it ensures that only one PPK is generated because the synchronizer fetches first info.json - and only generates a PPK if none is already present."))}h.isMDXComponent=!0}}]);