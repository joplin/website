"use strict";(self.webpackChunk_joplin_doc_builder=self.webpackChunk_joplin_doc_builder||[]).push([[3060],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||r;return n?i.createElement(m,o(o({ref:t},p),{},{components:n})):i.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7209:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return o},default:function(){return h},frontMatter:function(){return r},metadata:function(){return s},toc:function(){return c}});var i=n(87462),a=(n(67294),n(3905));const r={sidebar_label:"Synchronisation locks",title:"Synchronisation locks",description:"There are two types of locks: SYNC: Used when synchronising a client with a target. There can be multiple SYNC locks simultaneously. EXCLUSIVE: Used when a client upgrades a sync target. There can ..."},o="Synchronisation locks",s={unversionedId:"dev/spec/sync_lock",id:"dev/spec/sync_lock",title:"Synchronisation locks",description:"There are two types of locks: SYNC: Used when synchronising a client with a target. There can be multiple SYNC locks simultaneously. EXCLUSIVE: Used when a client upgrades a sync target. There can ...",source:"@site/help/dev/spec/sync_lock.md",sourceDirName:"dev/spec",slug:"/dev/spec/sync_lock",permalink:"/help/dev/spec/sync_lock",draft:!1,editUrl:"https://github.com/laurent22/joplin/tree/dev/readme/dev/spec/sync_lock.md",tags:[],version:"current",frontMatter:{sidebar_label:"Synchronisation locks",title:"Synchronisation locks",description:"There are two types of locks: SYNC: Used when synchronising a client with a target. There can be multiple SYNC locks simultaneously. EXCLUSIVE: Used when a client upgrades a sync target. There can ..."},sidebar:"helpSidebar",previous:{title:"Joplin synchronisation",permalink:"/help/dev/spec/sync"},next:{title:"Synchronous Scroll",permalink:"/help/dev/spec/sync_scroll"}},l={},c=[{value:"Timeout",id:"timeout",level:2},{value:"Acquiring a SYNC lock",id:"acquiring-a-sync-lock",level:2},{value:"Acquiring an EXCLUSIVE lock",id:"acquiring-an-exclusive-lock",level:2},{value:"Lock files",id:"lock-files",level:2},{value:"Sync Target Migration",id:"sync-target-migration",level:2}],p={toc:c},u="wrapper";function h(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"synchronisation-locks"},"Synchronisation locks"),(0,a.kt)("div",{className:"donate-links"},(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.paypal.com/donate/?business=E8JMYD2LQ8MMA&no_recurring=0&item_name=I+rely+on+donations+to+maintain+and+improve+the+Joplin+open+source+project.+Thank+you+for+your+help+-+it+makes+a+difference%21&currency_code=EUR"},(0,a.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Donate-PayPal-green.svg",alt:"Donate using PayPal"}))," ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sponsors/laurent22/"},(0,a.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/GitHub-Badge.svg",alt:"Sponsor on GitHub"}))," ",(0,a.kt)("a",{parentName:"p",href:"https://www.patreon.com/joplin"},(0,a.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Patreon-Badge.svg",alt:"Become a patron"}))," ",(0,a.kt)("a",{parentName:"p",href:"https://joplinapp.org/donate/#donations"},(0,a.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/laurent22/joplin/dev/Assets/WebsiteAssets/images/badges/Donate-IBAN.svg",alt:"Donate using IBAN"})))),(0,a.kt)("p",null,"There are two types of locks:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"SYNC"),": Used when synchronising a client with a target. There can be multiple SYNC locks simultaneously."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"EXCLUSIVE"),": Used when a client upgrades a sync target. There can be only one EXCLUSIVE lock.")),(0,a.kt)("h2",{id:"timeout"},"Timeout"),(0,a.kt)("p",null,"When a client acquires a lock, it must refresh it every X seconds. A lock timeout after Y seconds (where X ","<"," Y). A lock with a timestamp greater than Y is considered expired and can be ignored by other clients. A client that tries to refresh a lock that has expired should fail."),(0,a.kt)("p",null,"For example, if a client is currently syncing, it must stop doing so if it couldn't refresh the lock with Y seconds."),(0,a.kt)("p",null,"For example, if a client is upgrading a target, it must stop doing so if it couldn't refresh the lock within Y seconds."),(0,a.kt)("p",null,"If the previous lock has expired, we shouldn't try to acquire a new one. This is because other clients, seeing no active lock, might have performed in the meantime operations that invalidates the current operation. For example, another client might have upgraded the sync target, so any active sync with an expired lock should be cancelled. Or if the current client was upgrading the sync target, another client might have synced since then, making any cached data invalid."),(0,a.kt)("p",null,"In some cases it should be safe to re-acquire a lock but adding support for this would make the algorithm more complex without much benefits."),(0,a.kt)("h2",{id:"acquiring-a-sync-lock"},"Acquiring a SYNC lock"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The client check if there is a valid EXCLUSIVE lock on the target"),(0,a.kt)("li",{parentName:"ul"},"If there is, it must stop the sync process"),(0,a.kt)("li",{parentName:"ul"},"Otherwise it checks if it owns a SYNC lock on the target",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If it does, it starts syncing",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"When syncing is done, it releases the SYNC lock"))),(0,a.kt)("li",{parentName:"ul"},"If it doesn't, it acquires a SYNC lock and repeat the complete process from the beginning (to avoid race conditions)")))),(0,a.kt)("h2",{id:"acquiring-an-exclusive-lock"},"Acquiring an EXCLUSIVE lock"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The client check if there is a valid EXCLUSIVE or SYNC lock on the target"),(0,a.kt)("li",{parentName:"ul"},"If there is, it must stop the upgrade process (or wait till target is unlocked)"),(0,a.kt)("li",{parentName:"ul"},"Otherwise it checks if it owns an EXCLUSIVE lock on the target",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If it does, it starts upgrading the target",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"When upgrading is done, it releases the EXCLUSIVE lock"))),(0,a.kt)("li",{parentName:"ul"},"If it doesn't, it acquires an EXCLUSIVE lock and repeat the complete process from the beginning (to avoid race conditions)")))),(0,a.kt)("h2",{id:"lock-files"},"Lock files"),(0,a.kt)("p",null,"The lock files are in format ",(0,a.kt)("inlineCode",{parentName:"p"},"<lockType>_<clientType>_<clientId>.json"),' with lockType being "exclusive" or "sync", clientType being "desktop", "mobile" or "cli" and clientId is the globally unique ID assigned to a client profile when it is created.'),(0,a.kt)("p",null,"The have the following content:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "type": "exclusive",\n    "clientType": <string>,\n    "clientId": <string>,\n    "updatedTime": <timestamp in milliseconds>,\n}\n')),(0,a.kt)("p",null,"(Note that the lock file content is for information purpose only. Its content is not used in the lock algorithm since all data can be derived from the filename and file timestamp)"),(0,a.kt)("p",null,"Although only one client can acquire an exclusive lock, there can be multiple ",(0,a.kt)("inlineCode",{parentName:"p"},"exclusive_*.json")," lock files in the lock folder (for example if a client crashed before releasing a lock or if two clients try to acquire a lock at the exact same time). In this case, only the oldest lock amongst the active ones is the valid one. If there are two locks with the same timestamp, the one with lowest client ID is the valid one."),(0,a.kt)("h2",{id:"sync-target-migration"},"Sync Target Migration"),(0,a.kt)("p",null,"First the app checks the sync target version - if it's new (no version), it set it up by upgrading to the latest sync version."),(0,a.kt)("p",null,"If it's the same as the client supported version, it syncs as normal."),(0,a.kt)("p",null,"If it's lower than the client supported version, the client does not allow sync and instead displays a message asking the user to upgrade the sync target (upgradeState = SHOULD_UPGRADE)."),(0,a.kt)("p",null,"If the user click on the link to upgrade, upgradeState becomes MUST_UPGRADE, and the app restarts."),(0,a.kt)("p",null,"On startup, the app check the upgradeState setting. If it is MUST_UPGRADE it displays the upgrade screen and starts upgrading. Once done it sets upgradeState back to IDLE, and restart the app."))}h.isMDXComponent=!0}}]);